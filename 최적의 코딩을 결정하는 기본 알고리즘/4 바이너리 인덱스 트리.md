# 특수한 목적의 자료구조 : 바이너리 인덱스 트리



## 데이터 업데이트가 가능한 상황에서의 구간 합(Interval Sum) 문제

**BOJ '구간 합 구하기' 문제**

어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 1, 2, 3, 4, 5라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸로 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.

- **데이터 개수** : N (1<= N <= 1,000,000)
- **데이터 변경 횟수** : M (1<= M <= 10,000)
- **구간 합 계산 횟수** : K (1<= K <= 10,000)



### 해결방법 : 바이너리 인덱스 트리(Binary Index Tree)

**바이너리 인덱스 트리(Binary Index Tree)**는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조를 의미한다.

- **펜윅 트리(fenwick tree)**라고도 한다.

정수에 따른 2진수 표기

| 정수 | 2진수 표기                          |
| ---- | ----------------------------------- |
| 7    | 00000000 00000000 00000000 00000111 |
| -7   | 11111111 11111111 11111111 11111001 |

- **0이 아닌 마지막 비트를 찾는 방법**
  - 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서 **K & -K를 계산**



### 파이썬 구현 : K & -K 계산 결과 예시

4.py line1

| 정수 K | 2진수 표기 | K & -K |
| ------ | ---------- | ------ |
| 0      | 00000000   | 0      |
| 1      | 00000001   | 1      |
| 2      | 00000010   | 2      |
| 3      | 00000011   | 3      |
| 4      | 00000100   | 4      |
| 5      | 00000101   | 1      |
| 6      | 00000110   | 2      |
| 7      | 00000111   | 1      |
| 8      | 00001000   | 8      |



## 바이너리 인덱스 트리 : 트리 구조 만들기

**트리 구조 만들기** : 0이 아닌 마지막 트리 = 내가 저장하고 있는 값들의 개수

인덱스

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    |      | 3    |      | 5    |      | 7    |      | 9    |      | 11   |      | 13   |      | 15   |      |



### 바이너리 인덱스 트리 : 업데이트 (Update)

**특정 값을 변경할 때** : 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경 



### 바이너리 인덱스 트리 : 누적 합 (Prefix Sum)

**1부터 N까지의 합(누적 합) 구하기** : 0이 아닌 마지막 비트만틈 빼면서 구간들의 값의 합 계산



### 바이너리 인덱스 트리 구현 : 파이썬 (Python)

4.py line 8