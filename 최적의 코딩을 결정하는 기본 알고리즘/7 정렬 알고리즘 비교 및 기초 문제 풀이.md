# 정렬 알고리즘 비교 및 기초 문제 풀이

## 정렬 알고리즘 비교하기

앞서 다룬 네 가지 정렬 알고리즘을 비교하면 다음과 같다.

추가적으로 대부분의 프로그래밍 언어에서 지원하는 <u>표준 정렬 라이브러리는 최악의 경우에도 **O(NlogN)**을 보장</u>하도록 설계

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| ------------- | ---------------- | ----------- | ------------------------------------------------------------ |
| 선택 정렬     | O(N<sup>2</sup>) | O(N)        | 아이디어가 매우 간단하다.                                    |
| 삽입 정렬     | O(N<sup>2</sup>) | O(N)        | 데이터가 거의 정렬되어 있을 때는 가장 빠르다.                |
| 퀵 정렬       | O(NlogN)         | O(N)        | 대부분의 경우에 가장 적합하며, 충분히 빠르다.                |
| 계수 정렬     | O(N + K)         | O(N + K)    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작한다. |



### 선택 정렬과 기본 정렬 라이브러리 수행 시간 비교

7.py line 1

```python
실행 결과
선택 정렬 성능 측정:  15.896362066268921
기본 정렬 라이브러리 성능 측정:  0.0009839534759521484
```



## <문제> 두 배열의 원소 교체 : 문제 설명

두개의 배열 A와 B가 있다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다.

**최대 K번의 바꿔치기** 연산을 수행할 수 있는데, 

- 바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말한다.

최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이다.

N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 **배열 A의 모든 원소의 합의 최댓값을 출력**하는 프로그램 작성

예를 들어, N = 5, K = 3이고, 배열 A와 B가 다음과 같다고 할때

- 배열A = [1, 2, 5, 4, 3]
- 배열B = [5, 5, 6, 6, 5]

이 경우, 다음과 같이 세 번의 연산을 수행할 수 있다.

- 연산1) 배열 A의 원소 '1'과 배열 B의 원소 '6'을 바꾸기
- 연산2) 배열 A의 원소 '2'과 배열 B의 원소 '6'을 바꾸기
- 연산3) 배열 A의 원소 '3'과 배열 B의 원소 '5'을 바꾸기

세번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성될 것이다.

- 배열A = [6, 6, 5, 4, 5]
- 배열B = [3, 5, 1, 2, 5]

이때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없다.



### 문제 해결 아이디어

**핵심 아이디어** : <u>매번 배열 A에서 가장 작은 원소를 골라서, 배열 B에서 가장 큰 원소와 교체</u>한다.

가장 먼저 배열 A와 B가 주어지면 A에 대하여 오름차순 정렬하고, B에 대하여 내림차순 정렬한다.

이후에 두 배열의 원소를 첫 번째 인덱스부터 차례대로 확인하면서 A의 원소가 B의 원소보다 작을 때에만 교체를 수행한다.

이 문제에서는 두 배열의 원소가 최대 100,000개까지 입력될 수 있으므로, 최악의 경우 **O(NlogN)**을 보장하는 정렬 알고리즘을 이용해야 한다.



### 답안 예시(Python)

7.py line 49
