# 소수 여부를 빠르게 처리하는 알고리즘들

## 19차시

#### 소수(Prime Number)

**소수**란 <u>1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어떨어지지 않는 자연수</u>

+ **6**은 1,2,3,6으로 나누어떨어지므로 소수 X
+ **7**은 1과 7을 제외하고는 나누어떨어지지 않으므로 소수O

코딩테스트에서 어떤 자연수가 소수인지 아닌지 판별하는 문제 자주 출제



#### 소수의 판별: 기본적인 알고리즘(Python)

19.py 참고

+ 성능 분석
  + 2부터 x -1 까지모든 자연수에 대하여 연산 수행해야함
    + 모든 수를 하나씩 확인한다는 점에서 시간 복잡도는 **O(X)** 이다.



#### 약수의 성질

**모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭**을 이루는 것

따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 <u>가운데 약수(제곱급)까지만 확인</u>하면 됨



#### 소수의 판별: 개선된 알고리즘(Python)

19.py line13

+ 성능분석

  + 2부터 X의 제곱근(소수점 이하 무시)까지의 모든 자연수에 대하여 연산 수행

    + 시간 복잡도는

    $$
    O(N^\frac 1 2)
    $$

    

#### 다수의 소수 판별

<u>특정한 수의 범위 안에 존재하는 소수</u>를 찾아야 할때?

+ **에라토스테네스의 체 알고리즘** 사용



#### 에라토스테네스의 체 알고리즘

<u>다수의 자연수에 대해 소수 여부를 판별</u>할 때 사용 하는 대표적 알고리즘

에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾을 때 사용

에라토스테네스의 체 알고리즘의 **구체적인 동작 과정**

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다. (i = 소수)
3. 남은 수 중에서 i의 배수를 모두 제거 (i는 제거하지 않는다.)
4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복

<u>19.py line 28 참고</u>

+ 성능 분석
  + 에라토스테네스의 체 알고리즘의 시간 복잡도는 사실 선형 시간에 가까울 정도로 매우 빠르다.
    + 시간 복잡도는 **O(N log log N)**
  + 에라토스테네스의 체 알고리즘은 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용
    + 하지만 각 자연수에 대한 소수 여부를 저장해야 하므로 **메모리가 많이 필요**
    + **10억**이 소수인지 아닌지 판별시에는 적합하지 X (소수여부 기록하기 위해 10억개 만큼의 자연수 데이터가 들어갈 수 있을 만한 크기의 메모리가 필요 )

