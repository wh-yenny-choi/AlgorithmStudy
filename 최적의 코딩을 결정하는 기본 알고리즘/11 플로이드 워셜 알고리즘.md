# 플로이드 워셜 알고리즘 : 모든 출발지에서 다른 출발지까지 최단 경로 계산

## 플로이드 워셜 알고리즘 개요

<u>모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산</u>

플로이드 워셜(Floyd-Warshall)알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 **거쳐 가는 노드를 기준으로 알고리즘을 수행**한다.

- 다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.

플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다.

플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다.

각 단계마다 **특정한 노드 k를 거쳐 가는 경우를 확인**한다.

- a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사

점화식은 다음과 같다.
$$
D_{ab} = min(D_{ab}, D_{ak} + D_{kb})
$$
 

## 플로이드 워셜 알고리즘 : 동작 과정 살펴보기

**[초기상태]** 그래프를 준비하고 최단 거리 테이블을 초기화

- D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>)

**[Step 1]** 1번 노드(k = 1)를 거쳐 가는 경우를 고려하여 테이블을 갱신

- **점화식** : D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>a1</sub> + D<sub>1b</sub>)

- D<sub>23</sub> = min(D<sub>23</sub>, D<sub>21</sub> + D<sub>13</sub>)

**[Step 2]** 2번 노드(k = 2)를 거쳐 가는 경우를 고려하여 테이블을 갱신

- **점화식** : D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>a2</sub> + D<sub>2b</sub>)

- D<sub>13</sub> = min(D<sub>13</sub>, D<sub>12</sub> + D<sub>23</sub>)

**[Step 3]** 3번 노드(k = 3)를 거쳐 가는 경우를 고려하여 테이블을 갱신

- **점화식** : D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>a3</sub> + D<sub>3b</sub>)

- D<sub>14</sub> = min(D<sub>14</sub>, D<sub>13</sub> + D<sub>34</sub>)

**[Step 4]** 4번 노드(k = 4)를 거쳐 가는 경우를 고려하여 테이블을 갱신

- **점화식** : D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>a4</sub> + D<sub>4b</sub>)

- D<sub>12</sub> = min(D<sub>12</sub>, D<sub>14</sub> + D<sub>42</sub>)



## 플로이드 워셜 알고리즘 구현 (Python)

11.py line 1



## 플로이드 워셜 알고리즘 성능 분석

노드의 개수가 N개일 때 알고리즘상으로 N번의 단계를 수행합니다.

- 각 단계마다 **O(N<sup>2</sup>)**의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려한다.

따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 **O(N<sup>3</sup>)**입니다.

- 3중 반복문
- 복잡도가 너무 안좋아서 노드의 개수 501개 이상으로는 사실상 사용 불가능 
- 최단거리 계산문제에서 노드의 개수 500개 이하일때 만 사용







