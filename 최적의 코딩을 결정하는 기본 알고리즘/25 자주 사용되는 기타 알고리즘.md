# 자주 사용되는 기타 알고리즘: 투 포인터와 구간 합

## 투 포인터(Two pointers)

**투 포인터 알고리즘**은 <u>리스트에 순차적으로 접근해야 할 때 두개의 점의 위치를 기록하면서 처리</u>하는 알고리즘을 의미

흔히 2, 3, 4, 5, 6, 7번 학생 지목시 간단히 '2번부터 7번까지의 학생'이라고 부르곤 한다.

리스트에 담긴 데이터에 순차적으로 접근해야 할 때 **시작점**과 **끝점** 2개의 점으로 접근할 데이터의 범위를 표현할 수 있다.



## 특정한 합을 가지는 부분 연속 수열 찾기

### 문제 설명

N개의 자연수로 구성된 수열이 있다.

**합이 M인 부분 연속 수열의 개수**를 구하며, 수행 제한 시간은 **O(N)**이다.

- 선형적 동작 알고리즘



### 문제 해결 아이디어

<u>투 포인터를 활용</u>하여 다음과 같은 **알고리즘**으로 문제 해결

1. 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가르키도록 한다.
2. 현재 부분 합이 M과 같다면, 카운트한다.
3. 현재 부분 합이 M보다 작다면, end를 1 증가시킨다.
4. 현재 부분 합이 M보다 크거나 같다면, start를 1 증가시킨다.
5. 모든 경우를 확인할 때까지 2번 부터 4번까지의 과정 반복

예를들어 , M = 5

- [초기 단계] 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 한다.
  - 현재의 부분합은 1이므로 무시
  - **현재 카운트** : 0
- [Step 1] 이전 단계에서의 부분합이 1이었기 때문에 end를 1 증가시킨다.
  - 현재의 부분합은 3이므로 무시
  - **현재 카운트**: 0
- [Step 2] 이전 단계에서의 부분합이 3이었기 때문에 end를 1 증가시킨다.
  - 현재의 부분합은 6이므로 무시
  - **현재 카운트**: 0
- [Step 3] 이전 단계에서의 부분합이 6이었기 때문에 start를 1 증가시킨다.
  - 현재의 부분합은 5이므로 카운트를 증가시킨다.
  - **현재 카운트**: 1
- [Step 4] 이전 단계에서의 부분합이 5이었기 때문에 start를 1 증가시킨다.
  - 현재의 부분합은 3이므로 무시
  - **현재 카운트**: 1
- [Step 5] 이전 단계에서의 부분합이 3이었기 때문에 end를 1 증가시킨다.
  - 현재의 부분합은 5이므로 카운트를 증가시킨다.
  - **현재 카운트**: 2
- [Step 6] 이전 단계에서의 부분합이 5이었기 때문에 start를 1 증가시킨다.
  - 현재의 부분합은 2이므로 무시
  - **현재 카운트**: 2
- [Step 7] 이전 단계에서의 부분합이 2이었기 때문에 end를 1 증가시킨다.
  - 현재의 부분합은 7이므로 무시
  - **현재 카운트**: 2
- [Step 8] 이전 단계에서의 부분합이 7이었기 때문에 start를 1 증가시킨다.
  - 현재의 부분합은 5이므로 카운트를 증가시킨다.
  - **현재 카운트**: 3



### 코드 예시

25.py line 1





## 구간 합 (Interval Sum)

**구간 합 문제**: 연속적으로 나열된 N개의 수가 있을때 <u>특정 구간의 모든 수를 합한 값을 계산</u>하는 문제

예를 들어, 5개의 데이터로 구성된 수열 {10, 20, 30, 40, 50}이 있다고 가정

- 두 번째 수부터 네 번째 수까지의 합은 20 + 30 + 40 = 90 



## 구간 합 빠르게 계산하기

### 문제 설명

N개의 정수로 구성된 수열이 있다.

M개의 쿼리(Query) 정보가 주어진다.

- 각 쿼리는 Left와 Right로 구성
- 각 쿼리에 대하여 [Left, Right] 구간에 포함된 데이터들의 합을 출력해야 함
- 수행 시간 제한은 **O(N+M)**이다.



### 문제 해결 아이디어

**접두사 합(Prefix Sum)** : 배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것

접두사 합을 활용한 **알고리즘**은 다음과 같다

- N개의 수 위치 각각에 대하여 접두사 합을 계산하여 P에 저장
- 매 M개의 쿼리 정보를 확인할 때 구간 합은 *P[Right] - P[Left - 1]*이다

| 10   | 20   | 30   | 40   | 50   |
| ---- | ---- | ---- | ---- | ---- |

↓ Prefix Sum 계산

| 0    | 10   | 30   | 60   | 100  | 150  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| P[0] | P[1] | P[2] | P[3] | P[4] | P[5] |

1) *Left* = 1, *Right* = 3  →  P[3] - P[0] = 60

2) *Left* = 2, *Right* = 5  →  P[5] - P[1] = 140

​                                    ···

M) *Left* = 3, *Right* = 4  →  P[4] - P[2] = 70



### 코드 예시

25.py line 24
