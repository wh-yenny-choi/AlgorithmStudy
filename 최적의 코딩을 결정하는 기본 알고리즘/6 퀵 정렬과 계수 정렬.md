# 더 빠른 정렬 알고리즘 : 퀵 정렬과 계수 정렬

## 퀵 정렬

<u>기준 데이터를 설정</u>하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**이다.

일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나

병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘

가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)로 설정**



### 퀵 정렬 동작 예시

| 5    | 7    | 9    | 0    | 3    | 1    | 6    | 2    | 4    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

 	→																								←

**[Step 0]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경

| 5    | 4    | 9    | 0    | 3    | 1    | 6    | 2    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

**[Step 1]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '9'가 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경

| 5    | 4    | 2    | 0    | 3    | 1    | 6    | 9    | 4    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

**[Step 2]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'가 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '1'가 선택된다. 단, 이처럼 **위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경** 

| 1    | 4    | 2    | 0    | 3    | 5    | 6    | 9    | 4    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

**[분할 완료]** 이제 '5'의 왼쪽에 있는 데이터는 모두 5보다 작고, 오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있다. 이렇게 <u>피벗을 기준으로 데이터 묶음을 나누는 작업</u>을 **분할(Divide)**라고 한다.

- **[왼쪽 데이터 묶음 정렬]** 왼쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.

  | 1    | 4    | 2    | 0    | 3    |
  | ---- | ---- | ---- | ---- | ---- |

  ​	→																←

- **[오른쪽 데이터 묶음 정렬]** 오른쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.

  - 이러한 과정을 반복하면 전체 데이터에 대해서 정렬이 수행된다.

  | 6    | 9    | 7    | 8    |
  | ---- | ---- | ---- | ---- |

  ​	→													←



### 퀵 정렬이 빠른 이유 : 직관적인 이해

이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)를 기대할 수 있다.

- **너비 X 높이** = N x logN x NlogN



### 퀵 정렬의 시간 복잡도

퀵 정렬은 평균의 경우 **O(NlogN)**의 시간 복잡도를 가진다.

하지만 최악의 경우 **O(N<sup>2</sup>)**의 시간 복잡도를 가진다.

- 첫 번째 원소를 피벗으로 삼을때, 이미 정렬된 배열에 대해 퀵 정렬을 수행한다면?

  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |



### 퀵 정렬 소스코드 : 일반적인 방식 (Python)

6.py line1



### 퀵 정렬 소스코드 :  파이썬의 장점을 살린 방식

6.py line28



## 계수 정렬

특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는** 정렬 알고리즘

- 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때** 사용 가능

데이터의 개수가 N, 데이터(양수) 중 최대값이 K일 때 최악의 경우에도 수행 시간 **O(N + K)**를 보장한다.



### 계수 정렬 동작 예시

**[Step0] **가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성

- **정렬할 데이터** : 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

개수(Count)



**[Step1] **데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

- **정렬할 데이터** : **<u>7</u>** 5 9 0 3 1 6 2 9 1 4 8 0 5 2

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |

개수(Count)



**[Step2] **데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

- **정렬할 데이터** : 7 **<u>5</u>** 9 0 3 1 6 2 9 1 4 8 0 5 2

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    |

개수(Count)



**[Step3] **데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

- **정렬할 데이터** : 7 5 **<u>9</u>** 0 3 1 6 2 9 1 4 8 0 5 2

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 1    |

개수(Count)



**[Step15] **결과적으로 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록된다.

- **정렬할 데이터** : 7 5 9 0 3 1 6 2 9 1 4 8 0 5 **<u>2</u>**

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 2    | 2    | 1    | 1    | 2    | 1    | 1    | 1    | 2    |

개수(Count)



**결과를 확인할 때**는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력

인덱스

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 2    | 2    | 1    | 1    | 2    | 1    | 1    | 1    | 2    |

개수(Count)

- **출력 결과** : 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9



### 계수 정렬 정리

각각의 데이터가 몇번씩 등장했는지를 세는 방법. 즉, 카운터하는 방식으로 동작하는 정렬 알고리즘

가장 작은 데이터부터 가장 큰 데이터까지의 모든 범위를 포함할 수 있는 크기의 배열을 만들어야 하기 때문에 상대적으로 공간 복잡도가 높지만, 퀵 정렬과 비교했을 때도 조건만 만족한다면 더 효율적으로 동작한다.



### 계수 정렬 소스코드(Python)

6.py line 47



### 계수 정렬의 복잡도 분석

계수 정렬의 시간 복잡도와 공간 복잡도는 모두 **O(N + K)**이다.

- 데이터의 개수가 N, 데이터(양수) 중 최대값이 K

계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.

- 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해보자.

계수 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때** 효과적으로 사용할 수 있다.

- 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적이다.
