# CHAPTER05 DFS/BFS
> 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘

## <1> 꼭 필요한 자료구조 기초
**탐색 (Search)** ```많은 양의 데이터 중에서 원하는 데이터를 찾는 과정```
- DFS
- BFS
  - DFS와 BFS를 제대로 이해하려면 기본 자료구조인 스택과 큐에 대한 이해가 전제되어야 함

**자료구조 (Data Structure)** ```데이터를 표현하고 관리하고 처리하기 위한 구조```

스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성
- 삽입 (Push) : 데이터를 삽입한다.
- 삭제 (Pop) : 데이터를 삭제한다.

실제로 스택과 큐를 사용할 때는 삽입과 삭제 외에도 오버플로와 언더플로를 고민해야 한다
- 오버플로 : 특정한 자료구조가 수용한 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연삽을 수행할 때 발생. 즉, 저장 공간을 벗어나 데이터가 넘쳐흐를 때 발생
- 언더플로 : 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태

### 스택
> 5-1.py

**스택(Stack)** 은 박스 쌓기에 비유할 수 있다.

```선입후출(First In Last Out)구조 또는 후입선출(Last In First Out)구조```

스택을 이용할 때는 별도의 라이브러리를 사용할 필요 없다. 기본 리스트에서 append()와 pop()메서드 이용하면 스택 자료구조와 동일하게 동작
- append() 메서드 : 리스트의 가장 뒤쪽에 데이터를 삽입
- pop() 메서드 : 리스트의 가장 뒤쪽에서 데이터를 꺼냄

### 큐
> 5-2.py

**큐(Queue)** 는 대기줄에 비유할 수 있다.

```선입선출 (First In First Out) 구조```

큐 구현시 collections 모듈에서 제공하는 deque 자료구조를 활용
- deque : 스택과 큐의 장점을 모두 채택한 것

### 재귀함수
> 5-3.py

**재귀 함수(Recursive Function)** 란 ```자기 자신을 다시 호출하는 함수```

#### 재귀함수의 종료 조건
> 5-4.py
> 5-5.py

재귀 함수의 수행은 스택 자료구조를 이용한다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 떄문
- 연속해서 호출되는 함수는 메인 메모리의 스택 공간에 적재되므로 재귀 함수는 스택 자료구조와 같다는 말은 틀린말이 아니다.
- 재귀 함수는 내부적으로 스택 자료구조와 동일하다는 것
따라서, 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해 간편하게 구현될 수 있다.
- DFS
- 팩토리얼

-----------------------------------------------------------------
반복문 대신에 재귀 함수를 사용했을 때 얻을 수 있는 장점?
- 재귀 함수의 코드가 더 간결함 ➡ **재귀 함수는 반복문을 이용하는 것과 비교했을 때 더욱 간결한 형태이다**


## <2> 탐색 알고리즘 DFS / BFS
### DFS
> 5-8.py

**DFS**(Depth-First Search)```깊이 우선 탐색. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘```
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

그래프는 **노드(Node)** 와 **간선(Edge)** 로 표현되며, 이때 노드를 **정점(Vertex)** 이라고도 말한다.

그래프 탐색 : 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- 두 노드가 간선으로 연결되어 있다면 ➡ '두 노드는 인접하다'

**인접 행렬** : 2차원 배열로 그래프의 연결관계를 표현하는 방식
> 5-6.py
- 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
- 연결되어 있지 않은 노드끼리는 무한의 비용이라고 작성

**인접 리스트** : 리스트로 그래프의 연결 관계를 표현하는 방식
> 5-7.py
- '연결 리스트'라는 자료구조를 이용해 구현

### BFS 
> 5-9.py
**BFS (Breadth First Search)** ```너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘```
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

| |DFS|BFS|
|-------|----|----|
동작원리|스택|큐|
구현방법|재귀 함수 이용|큐 자료구조 이용|


## <3> 음료수 얼려 먹기
> 5-10.py

N x M 크기의 얼음 틀. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주

한 번에 만들 수 있는 아이스크림의 개수를 출력
1. 특정한 지점의 주변 상, 하, 좌, 우를 살펴본 뒤 주변 지점 중 값이 0이면서 아직 방문하지 않은 지점이 있다면 해당 지점 방문
2. 방문한 지점에서 다시 상, 하, 좌, 우를 살펴보면서 방문을 다시 진행하면, 연결된 모든 지점 방문 가능
3. 1~2번의 과정을 모든 노드에 반복하며 방문하지 않은 지점의 수를 센다.

**DFS**로 해결
- 공간이 상, 하, 좌, 우로 연결되어 있다고 표현
- 그래프 형태로 모델링 가능

## <4> 미로 탈출
> 5-11.py

N x M 미로 탈출. 위치는 (1, 1)이고 출구는 (N, M)의 위치에 존재하며 한번에 한 칸씩 이동한다. 이때 괴물이 있는 부분은 0, 없는 부분은 1로 표시.

탈출하기 위해 움직여야 하는 최소 칸 개수 구하기. 칸 셀때는 시작칸과 마지막 칸을 모두 포함해서 계산한다.

**BFS**로 해결
- 시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드 탐색
- (1, 1) 지점에서부터 BFS를 수행하여 모든 노드의 값을 거리 정보로 넣으면 됨
