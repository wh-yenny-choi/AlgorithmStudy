# CHAPTER10 그래프 이론
> 코딩 테스트에서 자주 등장하는 기타 그래프 이론 공부하기

## <1> 다양한 그래프 알고리즘
### 이미 배운 내용을 훑어보자
그래프 : 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조

**'서로 다른 개체가 연결되어 있다'** ➡ 그래프 알고리즘
- ex) 여러 개의 도시가 연결되어 있다

트리 자료구조 : 부모에서 자식으로 내려오는 계층적인 모델

다익스트라 최단 경로 알고리즘 ➡ 우선순위 큐 사용
- 우선순위 큐를 구현하기 위해 **최소 힙, 최대 힙** 이용
  - 최소 힙 : 항상 부모 노드가 자식 노드보다 크기가 작은 자료구조로서 트리 자료구조에 속함

크루스칼 알고리즘 ➡ 그리디 알고리즘

위상 정렬 알고리즘 ➡ 큐 자료 구조 혹은 스택 자료구조

그래프 구현 방법 2가지 방식
1. 인접 행렬 : 2차원 배열을 사용하는 방식
2. 인접 리스트 : 리스트를 사용하는 방식

우선순위 큐를 이용하는 다익스트라 최단 경로 알고리즘 ➡ 인접 리스트를 이용하는 방식
 
플로이드 워셜 알고리즘 ➡ 인접 행렬 이용하는 방식

어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야 한다.
- 최단 경로를 찾아야 하는 문제 출제시, 
  - 노드의 개수가 적은 경우 ➡ **플로이드 워셜 알고리즘**
  - 노드와 간선의 개수가 모두 많은 경우 ➡ 우선순위 큐를 이용하는 **다익스트라 알고리즘**
  
  기타 알고리즘
  - 서로소 집합, 신장 트리, 위상 정렬
  
### 서로소 집합
> 10-1.py
  
**서로소 집합 (Disjoint Sets)** ```공통 원소가 없는 두 집합```
  
서로소 집합 자료구조란 ```서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조```
- union과 find 2개의 연산으로 조작 가능
- union(합집합) 연산 : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
- find(찾기) 연산 : 특정한 원소가 속한 집합이 어떤 집합인지 알렺는 연산
- 스택과 큐가 각각 push, pop연산으로 이루어졌던 것처럼, 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.
  
서로소 집합 자료구조는 union-find (합치기 찾기) 자료구조라고 불리기도 한다.
- 두 집합이 서로소 관계인지를 확인할 수 있다는 말 = 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다는 말
  
#### 서로소 집합 자료구조
서로소 집합 자료구조 구현시 트리 자료구조를 이용하여 집합 표현
1. union 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인
2. 모든 union 연산을 처리할 때까지 1번 과정 반복
- 각각 루트 노드를 찾아서 더 큰 루트 노드가 더 작은 루트 노드를 가리키도록
  
서로소 집합 알고리즘으로 루트를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야 한다.
- union연산을 효과적으로 수행하기 위해 '부모 테이블'을 계속 확인하며 거슬러 올라가야 한다.
  
find혹은 union 연산의 시간복잡도는 비효율적이다. 하지만 이러한 find 함수는 최적화 가능 ➡ **경로 압축** 기법 적용
> 10-2.py
경로 압축 : find 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법
  
모든 union 함수를 처리한 후 각 원소에 대해 find함수를 수행하면 부모 테이블이 형성된다. 
> 10-3.py
- 경로 압축 기법을 이용시, 루트 노드에 더욱 빠르게 접근하여 기존 기본적인 알고리즘과 비교했을 때 시간 복잡도가 개선됨
  
#### 서로소 집합을 활용한 사이클 판별
> 10-4.py

서로소 집합은 무방향 그래프 내에서의 사이클 판별 할 수 있다. union연산을 이용하여 집합을 합치는 과정을 반복만 해도 사이클을 판별할 수 있다.
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
  1. 루트 노드가 서로 다르다면 두 노드에 대하여 union연산을 수행한다.
  2. 루트 노드가 서로 같다면 싸이클이 발생
2. 그래프에 포함되어 있는 모든 간선에 대해 1번 반복
  
이러한 사이클 판별 알고리즘은 그래프에 포함되어 있는 간선의 개수가 E개일 때 모든 간선을 하나씩 확인하며, 매 간선에 대해 union 및 find함수를 호출하는 방식으로 동작
- 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작
- 이 알고리즘은 간선에 방향성이 없는 무향 그래프에서만 적용 가능
  
### 신장 트리
**신장 트리 (Spanning Tree)** ```하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프```
  
#### 크루스칼 알고리즘
> 10-5.py

신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘 ➡ **최소 신장 트리 알고리즘**

대표적인 최소 신장 트리 알고리즘 ➡ **크루스칼 알고리즘**

크루스칼 알고리즘 : 적은 비용으로 모든 노드 연결 가능. 그리디 알고리즘으로 분류
1. 간선 데이터를 비용에 따라 오름차순으로 정렬
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
  1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
  2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
3. 모든 간선에 대해 2번의 과정을 반복

### 위상 정렬
> 10-6.py

**위상 정렬 (Topology Sort)** ```방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'```
- 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용 알고리즘
- 선후 관계를 지키는 전체 순서 계산 가능
- ex) 선수과목을 고려한 학습 순서 설정
- 진입차수 : 특정한 노드로 **들어오는** 간선의 개수

위상 정렬 알고리즘
1. 진입차수가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때까지 다음의 과정 반복
  1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
  2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.


## <2> 팀 결성
> 10-7.py

총 N + 1개의 팀 존재. '팀 합치기' 연산, '같은 팀 여부 확인' 연산 사용 가능.

M개의 연산을 수행할 때, '같은 팀 여부 확인' 연산에 대한 연산 결과 출력하는 프로그램 작성

'팀 합치기' 연산은 0 a b 형태. '같은 팀 여부 확인' 연산은 1 a b 형태

## <3> 도시 분할 계획
> 10-8.py

마을은 N개의 집과 그집들을 연결하는 M개의 길로 이루어져 있고, 어느 방향으로든지 다닐 수 있다.

A과 B의 집을 연결하는 길의 유지비가 C 이다.

길을 없애고 남은 길의 유지비의 합을 최소로 하는 프로그램을 작성

**문제 해설** 
- 전체 그래프에서 2개의 최소 신장 트리 생성
- 최소한의 비용으로 2개의 신장 트리로 분할 ➡ 크루스칼 알고리즘
- 최소 신장 트리를 찾은 뒤 최소 신장 트리를 구성하는 간선 중 가장 비용이 큰 간선을 제거 ➡ 최소 신장 트리가 2개의 부분 그래프로 나누어지는 최적의 해 도출


## <4> 커리큘럼
> 10-9.py

**문제 해설** : 위상 정렬 알고리즘의 응용 문제
- 각 노드에 대하여 인접한 노드를 확인할 때, 인접한 노드에 대하여 현재보다 강의 시간이 더 긴 경우를 찾는다면, 더 오랜 시간이 걸리는 경우의 시간 값을 저장하는 방식으로 결과 테이블을 갱신하여 답을 구할 수 있다.
- 따라서 위상 정렬을 수행하면서, 매번 간선 정보를 확인하여 결과 테이블 생신
- ```deepcopy()``` 함수를 이용하여 ```time``` 리스트 변수의 값을 복사하여 ```result``` 리스트 변수의 값으로 설정하는 작업 수행
- 단순히 대입 연산을 하면 값이 변경 될 때 문제가 되므로, 리스트의 값을 복제해야 할 때는 ```deepcopy()``` 함수 사용
  
