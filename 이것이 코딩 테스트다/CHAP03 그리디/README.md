# CHAPTER 03 그리디
> 현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘

## <1> 당장 좋은 것만 선택하는 그리디
Greedy 알고리즘은 문제를 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘.

```'현재 상황에서 지금 당장 좋은 것만 고르는 방법'```

그리디 알고리즘의 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠오릴 수 있는 능력 요구

문제에서 **'가장 큰 순서대로', '가장 작은 순서대로'** 같은 기준을 알게 모르게 제시

대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족할 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다.


### 예제 3-1. 거스름돈
> 3-1.py

```'가장 큰 화폐 단위부터' 돈을 거슬러 주는 것```


## <2> 큰 수의 법칙
> 3-2.py

```반복되는 수열에 대해서 파악하기```

다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙

단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징


## <3> 숫자 카드 게임
> 3-3.py
> 3-4.py

```각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수 찾기```

여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.
1. N x M 형태. N은 행의 개수, M은 열의 개수
2. 먼저 뽑고자 하는 카드가 포함된 행 선택
3. 그 다음 선택된 행에 포함된 카드 중 가장 숫자가 낮은 카드 뽑기
4. 최종적으로 가장 높은 숫자의 카드가 뽑을 수 있도록 전략 세우기

카드들이 N x M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오

## <4> 1이 될 때까지
> 3-5.py
> 3-6.py
```최대한 많이 나누기```

N이 1이 될때까지 반복적으로 선택하여 수행. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택 가능
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수 구하기
 
 N = 17, K = 4 일때, 전체 과정 실행 횟수 = 3. 이는 N을 1로 만드는 횟수
 
 
