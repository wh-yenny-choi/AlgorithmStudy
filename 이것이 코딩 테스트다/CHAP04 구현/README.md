# CHAPTER04. 구현
> 머릿속에 있는 알고리즘을 정확하고 빠르게 프로그램으로 작성하기

## <1> 아이디어를 코드로 바꾸는 구현
> 4-1.py
> 4-2.py

### 피지컬로 승부하기
구현 : 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정

problem - thinking - solution

**완전 탐색** 
```모든 경우의 수를 주저 없이 다 계산하는 해결 방법```

**시뮬레이션**
```문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행```

### 예제 4-1. 상하좌우
여행가 A는 L, R, U, D 방향으로 이동. 시작 좌표는 항상 (1,1)이며, 가장 오른쪽 좌표는 (N, N)

계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표 출력 프로그램 작성

### 예제 4-2. 시각
**완전 탐색 알고리즘**

정수 N이 입력되면 00시 00분 00초 부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 경우의 수를 구하는 프로그램 작성

00시 00분 00초 부터 N시 59분 59초까지 모든 경우의 수는 86,400가지

따라서 단순히 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지 확인하면 된다.

전체 시, 분, 초에 대한 경우의 수는 24 x 60 x 60이며 3중 반복문을 이용해 계산할 수 있다.

## <2> 왕실의 나이트왕실
> 4-3.py

8 x 8 좌표 평면. 특정한 한 칸에 나이트

이동할 때는 L자 형태로만 이동하며 좌표 밖으로 나갈 수 없다. 
1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동
나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램 작성

나이트의 이동 경로를 steps 변수에 넣는다면, 

```steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]```

나이트의 현재 위치가 주어지면 현재 위치에서 이동 경로를 더한 다음, 8 x 8 좌표 평면에 있는지 확인하면 됨

## <3> 게임 개발
> 4-4.py

N x M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다. 캐릭터는 동서남북 중 한 곳을 바라본다.

맵의 각 칸은 (A, B)로 나타날 수 있고, A는 북쪽으로부터 떨어진 칸의 캐수, B는 서쪽으로 부터 떨어진 칸의 개수

캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간은 갈 수 없다.
1. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸 전진한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.

캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램 만들기

전형적인 시뮬레이션 문제. 반복적인 숙달이 필요하다

일반적으로 **방향**을 설정해서 이동하는 문제 유형에서는 **dx, dy라는 별도의 리스트를 만들어 방향을 정하는 것**이 효과적이다.




