# CHAPTER08 다이나믹 프로그래밍
> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

## <1> 다이나믹 프로그래밍
### 중복되는 연산을 줄이자
> 다이나믹 프로그래밍 ↔ 동적 할당 다이나믹
> - 프로그래밍에서 다이나믹 : 프로그램이 실행되는 도중에
> - 동적 할당 : 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법

**다이나믹 프로그래밍 (Dynamic Programming)** : 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법 중 하나

```큰 문제를 작게 나누고, 같은 문제라면 한 ㅂ너씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법```

다이나믹 프로그래밍의 방식
1. 탑다운 (Top-down)
2. 보텀업 (Bottom-up)

다이나믹 프로그래밍으로 해결할 수 있는 대표적 예시 ➡ 피보나치 수열
- 피보나치 수열 : 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열
- 피보나치 함수 f(n) 함수에 n이 커질수록 수행 시간이 기하급수적으로 늘어난다
  - 피보나치 수열의 점화식을 재귀 함수를 사용해 만들 수는 있지만, 효율적이지 않다.

프로그래밍에서는 수열을 **배열** 이나 **리스트** 로 표현 가능
> 8-1.py
- 수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미하는 것이기 때문
- 리스트나 배열 모두 '연속된 많은 데이터'를 처리한다는 점은 동일
- 수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단

다이나믹 프로그래밍 사용 조건
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열의 문제는 **메모이제이션(Memoization)** 기법 사용해서 해결 가능
> 8-2.py
- 메모이제이션(Memoization) : 다이나믹 프로그래밍을 구현하는 방법 중 한 종류. 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법 의미
- 메모이제이션은 값을 저장하는 방법이므로 **캐싱(Caching)** 이라고도 한다.

큰 문제를 작게 나누는 방식 ➡ 다이나믹 프로그래밍, **퀵정렬**
> 8-3.py
- 퀵정렬 ➡ 정렬 수행 시 정렬할 리스트를 분할하며 전체적으로 정렬이 될 수 있도록함 ➡ **분할 정복 알고리즘** 으로 분류됨
- 다이나믹 프로그래밍 ↔ 퀵정렬 : 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있음
  - 퀵정렬 : 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡게 되면 그 기준 원소의 위치는 더 이상 바뀌지 않고 그 피벗값을 다시 처리하는 부분 문제는 존재❌
  - 다이나믹 프로그래밍 : 한 번 해결했던 문제를 다시금 해결한다는 점이 특징 ➡ 이미 해결된 부분 문제에 대한 답을 정해놓고, 이 문제는 이미 해결 됐던 것이니까 다시 해결할 필요 없다고 반환
  
##### 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법
**탑다운(Top-Down) 방식** = 하향식 
- 큰 문제를 해결하기 위해 작은 문제를 호출함
- **메모이제이션** 은 탑다운 방식에 국한되어 사용되는 표현
  - 메모이제이션 : 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념으로, 다이나믹 프로그래밍과는 별도의 개념. 한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
  - 메모이제이션은 때에 따라서 다른 자료형 (예를 들면 dict(사전)자료형)을 이용할 수도 있다.
    - 사전 자료형은 수열처럼 연속적이지 않은 경우 유용 (모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우 존재 시)

**보텀업 (Bottome-Up) 방식** = 상향식 
> 8-4.py
- 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출함
- 다이나믹 프로그래밍의 전형적인 형태
- 결과 저장용 리스트 'DP테이블'

재귀적인 피보나치 수열의 소스코드에서 오천 번째 이상의 큰 피보나치 수를 구하도록 하면 'recursion depth(재귀 함수 깊이)' 오류 발생
- 이 경우 ```sys``` 라이브러리의 ```setrecursionlimit()``` 함수 호출하여 재귀 제한 완화

## <2> 1로 만들기
> 8-5.py

정수 X에 사용될 수 있는 연산 4가지
1. X가 5로 나누어떨어지면, 5로 나눈다.
2. X가 3로 나누어떨어지면, 3으로 나눈다.
3. X가 2로 나누어떨어지면, 2로 나눈다.
4. X에서 1을 뺀다.

정수 X가 주어질 때, 연산 4개를 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력

**점화식** : 1빼는 연산 제외, 해당 수로 나누어 떨어질 때 한해 점화식 적용

ex)
1. 26-1 = 25
2. 25/5 = 5
3. 5/5 = 1

보텀업 다이나믹 프로그래밍을 소스코드로 작성. ```min()``` 함수 이용.

## <3> 개미 전사
> 8-6.py

최소한 한 칸 떨어진 식량창고 약탈. 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램 작성

** 점화식** : i번째 까지의 최적의 해

## <4> 바닥공사
> 8-7.py

가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥. 1 x 2, 2 x 1, 2 x 2의 덮개를 이용해 바닥을 채우는 모든 경우의 수
- 출력 조건 : 방법의 수를 796,796으로 나눈 나머지 출력

다이나믹 프로그래밍의 기초 예제에서 빠질 수 없는 타일링 문제 유형
- 다이나믹 프로그래밍 문제에서는 종종 결과를 어떤 수로 나눈 결과를 출력하라는 내용이 들어가 있는 경우가 많다.

## <5> 효율적인 화폐 구성
>  8-8.py

N가지 종류의 화폐들 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 

이 문제는 그리디에서 다루었던 거스름돈 문제와 거의 동일하다. 단지 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다. 그렇기 때문에 그리디 알고리즘 처럼 매번 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없고 다이나믹 프로그래밍을 이용해야 한다. 

**점화식** : 각 화폐 단위인 K를 하나씩 확인하며

